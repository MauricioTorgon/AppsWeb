:root {
    --blanco: #fff;
    --oscuro: #212121;
    --primario: #ffc107;
    --secundario: #0097a7;
    --gris: #757575;
    --grisClaro: #dfe9f3;
}

/*Globales*/
html{
    font-size: 62.5%;
    background-color: var(--blanco);
    box-sizing: border-box;
}

*, *:before, *:after{
    box-sizing: inherit;
} 
/*Sirve para que el tamaño de los elementos sea el dado y no
se aumente por el padding o margin, entre otros.*/

body{
    font-size: 16px; /* 1rem=10px*/
    font-family: 'Krub', sans-serif;
    background-image: linear-gradient(to bottom, var(--grisClaro) 0%, var(--blanco) 100%);
    color: var(--oscuro);
}

.contenedor{
    max-width: 120rem; /* 1200px */
    margin: 0 auto; 
    /* si solo hay 2 valores, el primer valor es el de arriba y abajo y el segundo el de derecha e izquierda respectivamente */
    /*margin-top: 0;
    margin-right: auto;
    margin-bottom: 0;
    margin-left: auto;*/
}

.boton{
    background-color: var(--secundario);
    color: var(--blanco);
    padding: 1rem 3rem;
    margin-top: 1rem;
    font-size: 2rem;
    text-decoration: none;
    text-transform: uppercase;
    font-weight: 700;
    border-radius: 5px;
    width: 80%;
    text-align: center;
    border: none;
}
@media (min-width: 480px) {
    .boton{
        width: auto;
    }
    
}
.boton:hover{
    background-color: var(--primario);
    color: var(--oscuro);
    cursor: pointer;
}

.sombra{
    cursor: pointer;
}

/*Tipografía*/
h1{
    font-size: 3.8rem;
}

h2{
    font-size: 2.8rem;
}

h3{
    font-size: 1.8rem;
}
h1, h2, h3{
    text-align: center;
}

.titulo span{ 
    /*h1 span es lo mismo ya que solo hay un h1 o titulo
     que usar. Pero hay mas elementos de los demás
     por lo que conviene usar clases */
    font-size: 2rem;
}
h2{
    font-size: 2.5rem;
}
h2 span{
    font-size: 1.8rem;
}


/*Navegacion*/
.nav-bg{
    background-color: var(--secundario);
}

.navegacion-principal{
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    align-items: center;
    /* en el caso de flex-direction:column (arriba a abajo); justify-content no funciona
    Eso deja obsoleto a justify teniendo que utilizar align-items: center; para centrar verticalmente*/
}

@media (min-width: 768px) {
    .navegacion-principal{
        flex-direction: row;
        align-items: center; /*centra verticalmente*/
    }
    
}

.navegacion-principal a{
    display : block; /*para que ocupe todo el ancho*/
    text-align: center; /*centra verticalmente*/
    color: var(--blanco);
    text-decoration: none;
    font-size: 2rem;
    font-weight: 700; /* negritas*/
    padding: 1rem; /*sin opción es igual a las 4 direcciones*/
}

.navegacion-principal a:hover{
    background-color: var(--primario);
    color: var(--oscuro)
}


/*Hero*/
/*Hero es una sección destacada que suele contener una imagen de fondo y un mensaje principal*/
.hero{
    background-image: url('../img/hero.jpg');
    background-repeat: no-repeat;
    background-size: cover;
    height: 450px;
    position:relative;
    margin-bottom: 2rem;
}

.contenido-hero{
    position: absolute;
    background-color: rgba(0, 0, 0, 0.7); /*sintaxis antes, se aplica si el nuevo no tiene soporte*/
    background-color: rgb(0 0 0 0 /70%); /*sintaxis ahora*/
    width: 100%;
    height: 100%;

    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
}

.contenido-hero p,.contenido-hero h2{
    color: var(--blanco);
}

.ubicacion{
    display: flex;
    align-items: flex-start;
}

/*Servicios*/
.servicios{
    display: grid;
    grid-template-columns: 1fr; 
    /*3 columnas de igual tamaño. Tambien puede ser 33.3% 33.3% 33.3% 
                                            o bien  1fr 1fr 1fr*/
    grid-template-rows: 1fr;

    /*grid: 20rem 80rem / 30rem 30rem;*/ /*Alternativa ahorra codigo*/
}@media (min-width: 768px) {
    .servicios{
        grid-template-columns: repeat(3, 1fr); /*3 columnas de igual tamaño*/
        column-gap: 1rem;;
    }
    
}

.servicio {

    display: flex  ;
    flex-direction: column;
    align-items: center;
}

.servicio h3{
    color: var(--secundario);
    font-weight: normal;
}

.servicio p{
    line-height: 1.8;
    text-align: center;
}

.servicio .iconos{
    height: 15rem;
    width: 15rem;
    background-color: var(--primario);
    border-radius: 50%;
    display: flex;
    justify-content: space-evenly;
    align-items: center;
    
}

/*Contacto*/
.formulario{
    background-color: var(--gris);
    width: min(60rem, 100%); /*utiliza el valor mas pequeño*/
    margin: 0 auto;
    padding: 2rem;
    border-radius: 1rem;
}
.formulario legend{
    font-size: 1.8rem;
    text-align: center;
    text-transform: uppercase;
    color: var(--primario);
    font-weight: 700;
    margin-bottom: 2rem;
}
.formulario fieldset{
    border: none
}

.contenedor-campos{

}

.campo {
    margin-bottom: 1rem;
}

.campo label{
    color: var(--blanco);
    font-weight: 700;
    margin-bottom: 0.5rem;
    display: block; /*para que ocupe todo el ancho*/
}

.input-text, textarea{
    width: 100%;
    padding: 1rem;
    border: none;
    border-radius: 5px;
    font-size: 1.6rem;
}

.enviar .boton{
    width: 100%;
}@media (min-width: 780px) {
    .enviar .boton{
        display: flex;
        justify-self: right;
        align-items: end;
        width: auto;
    }
    
}
/*  Metodologías de CSS
BEM - Block Element Modifier
BEM es una metodología para nombrar clases de CSS que ayuda a mantener el código organizado y
fácil de entender.
- Block: Representa un componente independiente (ej. .navegacion-principal).
- Element: Representa una parte del bloque que no puede existir por sí sola (ej. .navegacion-principal__boton).
pero cuando se utiliza un comportamiento se usa un modifier, por ejemplo cuando se usa un botón activo:
- Modifier: Representa una variación del bloque o elemento (ej. .navegacion-principal__boton--activo).

Utility First
Utility First es una metodología de CSS que se centra en crear clases pequeñas y reutilizables
Si quieres centrar un texto, en lugar de crear una clase específica como .centrar-texto, se utiliza una clase utilitaria como .text-center.
Esto permite una mayor flexibilidad y reutilización del código, ya que las clases utilitarias
pueden combinarse para crear estilos más complejos sin necesidad de crear nuevas clases específicas.

Modulos
Modular CSS es una metodología que divide el CSS en módulos independientes y reutilizables.
Cada módulo representa un componente o una parte específica de la interfaz de usuario.
Es el utilizado en este proyecto combinado con Utilidades.

Es posible combinar estas metodologías para aprovechar sus ventajas.
por ejemplo, Bootstrap usa módulos y utilities.
*/